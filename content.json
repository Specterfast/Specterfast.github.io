{"meta":{"title":"Specter's Blog","subtitle":null,"description":null,"author":"Specter","url":"https://specters.top"},"pages":[{"title":"about","date":"2018-11-03T12:23:30.000Z","updated":"2018-11-04T12:58:33.720Z","comments":true,"path":"about/index.html","permalink":"https://specters.top/about/index.html","excerpt":"","text":"座右铭得之坦然，失之淡然。争其必然，顺其自然。"},{"title":"categories","date":"2018-11-03T12:23:15.000Z","updated":"2018-11-03T12:28:58.771Z","comments":true,"path":"categories/index.html","permalink":"https://specters.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-03T12:18:50.000Z","updated":"2018-11-03T13:15:01.053Z","comments":true,"path":"tags/index.html","permalink":"https://specters.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"kkk","slug":"kkk","date":"2018-11-08T12:38:27.000Z","updated":"2018-11-08T12:38:49.750Z","comments":true,"path":"2018/11/08/kkk/","link":"","permalink":"https://specters.top/2018/11/08/kkk/","excerpt":"","text":"撒大声地所多奋斗的方法","categories":[],"tags":[]},{"title":"最大子段和","slug":"最大子段和","date":"2018-11-06T14:16:29.000Z","updated":"2018-11-06T14:25:25.022Z","comments":true,"path":"2018/11/06/最大子段和/","link":"","permalink":"https://specters.top/2018/11/06/最大子段和/","excerpt":"给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。","text":"给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。 动态规划方程b[j]=max(b[j-1]+a[j],a[j]) 1&lt;=j&lt;=n 最大子段和核心算法1234567891011int maxsum(int *a,int n)&#123; int b=0,sum=0; for(int i=1;i&lt;=n;i++) &#123; if(b&gt;0)b+=a[i]; else b=a[i]; if(b&gt;sum)sum=b; &#125; return sum;&#125; 全部代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int Maxsum(int n,int *a)&#123; int sum=0,b=0; for(int i=1;i&lt;=n;i++) &#123; if(b&gt;0)b+=a[i]; else b=a[i]; if(b&gt;sum)sum=b; &#125; return sum; &#125; int main()&#123; int m; cin&gt;&gt;m; for(int t=0;t&lt;m;t++) &#123; int *n=new int(m); for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;n[j]; int *p=new int(n[j]); for(int i=1;i&lt;=n[j];i++) cin&gt;&gt;p[i]; int t=Maxsum(n[j],p); cout&lt;&lt;t&lt;&lt;endl; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://specters.top/categories/算法/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://specters.top/categories/算法/动态规划/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://specters.top/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://specters.top/tags/动态规划/"}]},{"title":"最长公共子序列","slug":"最长公共子序列","date":"2018-11-06T14:04:07.000Z","updated":"2018-11-06T14:13:33.525Z","comments":true,"path":"2018/11/06/最长公共子序列/","link":"","permalink":"https://specters.top/2018/11/06/最长公共子序列/","excerpt":"求解两个字符串的最长公共子序列","text":"求解两个字符串的最长公共子序列 题目描述 最长公共子序列最优解(最大长度)1234567891011121314151617181920212223242526void LCSlength(int m,int n,char *x,char *y,int **c,int **b)&#123; int i,j; for(i=1;i&lt;=m;i++)c[i][0]=0; for(i=1;i&lt;=n;i++)c[0][i]=0; //i=0或者j=0,最长公共子序列为空 for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++) &#123; if(x[i]==y[j]) //x[i]=y[j]时,c[i][j]=斜上方的c[i-1][j-1]+1 &#123; c[i][j]=c[i-1][j-1]+1; b[i][j]=1; //b[i][j]=1;表示c[i][j]来自斜上方的值+1而来 &#125; //下面 max(c[i-1][j],c[][j-1]) else if(c[i-1][j]&gt;c[i][j-1]) &#123; c[i][j]=c[i-1][j]; b[i][j]=2; //b[i][j]=2;表示c[i][j]来自正上方的值+1而来 &#125; else &#123; c[i][j]=c[i][j-1]; b[i][j]=3; //b[i][j]=3;表示c[i][j]来自左方的值+1而来 &#125; &#125;&#125; 最优解的序列12345678910111213void LCS(int i,int j,char *x,char **b)&#123; if(i==0||j==0)return; if(b[i][j]==1) &#123; LCS(i-1,j-1,x,b); cout&lt;&lt;x[i]; &#125; else if(b[i][j]==2) LCS(i-1,j,x,b); else LCS(i,j-1,x,b);&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;int c[2000][2000];char x[2000],y[2000];/*最优解，输出公共序列void LCS(int i,int j)&#123; if(i==0||j==0)return; if(b[i][j]==1) &#123; LCS(i-1,j-1,x,b); cout&lt;&lt;x[i-1]; &#125; else if(b[i][j]==2) LCS(i-1,j); else LCS(i,j-1);&#125;*/int LCSLength(int m,int n)&#123; int i, j; int len; for (i = 1; i &lt;= m; i++) c[i][0] = 0; for (i = 1; i&lt;=n; i++) c[0][i] = 0; for (i = 1; i &lt;= m; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (x[i-1]==y[j-1]) &#123; c[i][j] = c[i - 1][j - 1] + 1; &#125; else if (c[i - 1][j] &gt;=c[i][j - 1]) &#123; c[i][j] = c[i - 1][j]; &#125; else &#123; c[i][j] = c[i][j - 1]; &#125; &#125; &#125; len = c[m][n]; return len;&#125;int main(void)&#123; int m,n, len; while(cin &gt;&gt; x)&#123; cin &gt;&gt; y; m= strlen(x); n= strlen(y); len = LCSLength(m,n); cout &lt;&lt; len &lt;&lt; endl; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://specters.top/categories/算法/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://specters.top/categories/算法/动态规划/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://specters.top/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://specters.top/tags/动态规划/"}]},{"title":"0-1背包","slug":"0-1背包","date":"2018-11-06T13:03:10.000Z","updated":"2018-11-06T14:25:54.072Z","comments":true,"path":"2018/11/06/0-1背包/","link":"","permalink":"https://specters.top/2018/11/06/0-1背包/","excerpt":"关于0-1背包的两种解法","text":"关于0-1背包的两种解法 题目描述背包容量c=10 物品数量n=5 输入五个物品的重量w[i]和价值v[i] 求最大价值。 二维数组存储最优解代码如下1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int m[1000][1000];void knapsack(int *v,int *w,int n,int c)&#123; int jmax=min(w[n]-1,c); for(int j=0;j&lt;=jmax;j++)m[n][j]=0; for(int j=w[n];j&lt;=c;j++)m[n][j]=v[n]; for(int i=n-1;i&gt;1;i--) &#123; int jmax=min(w[i]-1,c); for(int j=0;j&lt;=jmax;j++) m[i][j]=m[i+1][j]; for(int j=w[i];j&lt;=c;j++) m[i][j]=max(m[i+1][j],m[i+1][j-w[i]]+v[i]); &#125; m[1][c]=m[2][c]; if(c&gt;=w[1])m[1][c]=max(m[1][c],m[2][c-w[1]]+v[1]);&#125;int main()&#123; int c=10; //背包容量 int n=5; //物品数目 int v[10]=&#123;0&#125;,w[10]=&#123;0&#125;;//v[]价值，w[]重量 for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; knapsack(v,w,n,c); cout&lt;&lt;m[1][c];&#125; 一维数组存储最优解代码如下：123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int m[1000];int main()&#123; int c=10; int n=5; int v[10]=&#123;0&#125;,w[10]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=1;i&lt;=n;i++) for(int j=c;j&gt;=w[i];j--) m[j]=max(m[j],m[j-w[i]]+v[i]); cout&lt;&lt;m[c];&#125; 这是构造最优解的算法 ,即放入哪些物品。123456789101112void traceback(int **m,int *w,int c,int n,int *x)&#123; for(int i=1;i&lt;n;i++) //1--放入 0--不放入 if(m[i][c]==m[i+1][c]) x[i]=0; else &#123; x[i]=1; c-=w[i]; &#125; x[n]=(m[n][c])?1:c;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://specters.top/categories/算法/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://specters.top/categories/算法/动态规划/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://specters.top/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://specters.top/tags/动态规划/"}]},{"title":"矩阵连乘","slug":"矩阵连乘","date":"2018-11-02T07:28:05.000Z","updated":"2018-11-08T01:16:15.052Z","comments":true,"path":"2018/11/02/矩阵连乘/","link":"","permalink":"https://specters.top/2018/11/02/矩阵连乘/","excerpt":"算法是一门让我很头疼的课程，因为平时也不怎么写代码，现在学了算法了，来总结一下一些基本算法。","text":"算法是一门让我很头疼的课程，因为平时也不怎么写代码，现在学了算法了，来总结一下一些基本算法。 矩阵连乘最优值(最少数乘次数)1234567891011121314151617181920212223void matrixchain(int *p,int n,int **m,int **s)&#123; for(int i=1;i&lt;=n;i++)m[i][i]=0; for(int r=2;r&lt;=n;r++) for(int i=1;i&lt;=n-r+1;i++) //行 &#123; int j=i+r-1; //列 m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j];//在i处断开, //m[i][j]=m[i][i]+m[i+1][j]+p[i-1]*p[i]*p[j], //而m[i][i]=0,所以m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j] s[i][j]=i; //i处断开 for(int k=i+1;k&lt;j;k++) &#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; //k=i+1,表示从i以后的点处断开 if(t&lt;m[i][j]) &#123; m[i][j]=t; s[i][j]=k; &#125; &#125; &#125; &#125; 输出最优解12345678void trackback(int i,int j,int **s)&#123; if(i==j)return; trackback(i,s[i][j],s); trackback(s[i][j]+1,j,s); cout&lt;&lt;\"Mulitiply A\"&lt;&lt;i&lt;&lt;\",\"&lt;&lt;s[i][j]; cout&lt;&lt;\"and A\"&lt;&lt;(s[i][j]+1)&lt;&lt;\",\"&lt;&lt;j&lt;&lt;endl; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://specters.top/categories/算法/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://specters.top/categories/算法/动态规划/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://specters.top/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://specters.top/tags/动态规划/"}]},{"title":"Linux命令简介","slug":"Linux命令简介","date":"2018-10-29T13:51:19.000Z","updated":"2018-11-02T07:26:46.239Z","comments":true,"path":"2018/10/29/Linux命令简介/","link":"","permalink":"https://specters.top/2018/10/29/Linux命令简介/","excerpt":"这些是我自己在学习过程中，遇到的一些常用到的命令。","text":"这些是我自己在学习过程中，遇到的一些常用到的命令。有些可能不太正确，多多见谅。 linux简介在linux中任何内容都是文件 硬件设备文件名 /dev/… 第一个’/‘代表的是根目录，dev目录下保存的都是硬件设备文件名 根目录下的bin和sbin，usr目录下的bin和sbin这四个目录都是用来保存系统命令的 /etc/ 目录下一般都是配置文件 /lib/ 目录下一般都是Linux的函数库 proc和sys 目录不应该 操作，这两个目录保存的是内存的过载点 所以不应该在Linux下任何一个文件夹内乱写东西，可以在家目录root或home，以及temp目录下随便放内容 uname -a ： 查看系统信息 直接输入某应用程序的名字会将其打开，如root@root1-virtual-machine:~# firefox，可以用root@root1-virtual-machine:~# firefox &amp; 使其在后台打开 root@root1-virtual-machine:~# firefox www.baidu.com 则会打开百度 文件和目录的管理打开文件夹的方法使用：cd 目录 —–进入某目录，cd ..进入上级目录，cd / 进入根目录，ll —-查看文件夹里的文件pwd 显示当前目录 打开文件的方法： 编辑文件用 vi 文件名 或者 vim 文件名。 vi是Linux终端下或控制台下常用的编辑器， 基本的操作方式为：vi /路径/文件名 例如，vi /etc/fstab表示显示/etc/fstab文件的内容。使用键盘上的Page Up和Page Down键可以上下翻页;按下Insert键，可以见到窗口左下角有“Insert”字样，表示当前为插入编辑状态，这时从键盘输入的内容将插入到光标位置;再按下Insert键，左下角将有“Replace”字样，表示当前为替换编辑状态，这时从键盘输入的内容将替换光标位置的内容。编辑完内容后，按下Esc键，并输入“:wq”，然后回车就可以保存退出。 如果不想保存而直接退出，则按下Esc键后，输入“:q!”，然后回车即可。“wq”表示Write和Quit，即保存退出;“q!”表示忽略修改强行退出。 查看文件n内容用 cat 文件名 或 less 文件名ls:查看当前目录下的目录或文件 ls -a 查看所有文件，包括隐藏文件 ls -l查看所有目录和权限等各种属性 drwxr-xr-x 2 root1 root1 4096 3月 12 23:14 Templates 查到的权限像这样， d 表示的是这是一个目录 零散的文件操作 ls &gt; currentdir 输出重定向，ls &gt; currentdir 命令 会把当前目录放到currentfir中，用cat currentdir可以查看（会覆盖一些文件，慎用ls currentdir较好） cat：查看文件内容，cat &lt;&lt; aa 输入重定向， 碰到aa会结束（aa为人已字符） cat -n 文件 显示文件行号 more： 查看文件内容，会把文件分页，方便查看，也可以cat|more less： 显示文本文件的内容 可以移动光标，在文件底部，输入q会退出 grep ：grep aa 文件 ， 在文件中查找含有aa的部分 locate ：查找系统中的一些目录或文件 locate a 查找系统中含有a的目录或文件 whereis： whereis+文件、程序、命令 查找出文件、程序、或命令的存放位置和相关信息 which： which+文件、程序、命令 查看文件、程序、命令存放在那个目录中 who： 查看哪些用户登录，以及其登陆的控制台， whoami 可以显示当前登录的用户 touch：创建一个文件 mkdir：创建一个目录 mv：移动一个文件或者目录到连一个目录下 mv -b 可以避免同名文件被覆盖，原文件后会有一个~ mv a（文件） b（文件）把a重命名为b rmdir：删除一个空目录 cp：复制一个文件到一个目录下 rm：删除文件 ，rm -i 询问是否删除，rm -r 删除任何文件或目录 ln： ln aa bb 给aa创建一个硬链接，bb是一个实实在在的文件，但如果改变aa，bb也会改变。但如果删除aa，bb还会存在。 ln -s aa bb 给aa创建一个符号链接文件bb ln -s aa/ bb 给aa目录创建一个符号链接文件bb （链接文件类似一个文件的快捷方式，不是一个真正的文件，-s就是为了指明该文件是链接文件） | : 管道符号（竖线），可以将一条命令的输出连接到另一条命令的输入 a|b a的输出作为b的输入 grep：过滤， ls | grep a 在ls输出的目录下 过滤出含有a字段的目录 权限问题 chown： 更改文件的所有权：sudo chown root1 aa drwxr-xr-x 2 root root 4096 3月 13 20:45 aa 会变成 drwxr-xr-x 2 root1 root 4096 3月 13 20:45 aa 更改目录及目录下的所有文件 sudo chown -R root1 b chmod: 改变一个文件的权限 文件属主用u表示，其他人用o表示，所有人用a表示， || r表示读，w表示写，x表示执行 chmod u+x aa 使aa文件给文件属主增加执行权限 chmod u-x aa 代表取消该权限 rwx 表示该目录对创建者来说拥有读，写和执行的权限， r-x 表示文件所有者所在组的权限读和执行 第二个r-x 表示其他人的权限 2 表示文件数目 第一个 root1 ：用户 第二个 root1： 用户组 4096 是文件大小 06-29 14:30 是创建时间 test 文件名 用户与组管理 history：可以查看 使用过的系统命令 su 命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。 sudo useradd 新用户名 –》增加新用户 sudo passwd 新用户名 增加密码 sudo useradd -m 新用户名 ，可以添加新用户，sudo passwd 用户名 增加 -m 参数，可以把该用户添加到主目录下，用于开机时的登录，如果不加-m，则不能登录 sudo userdel 用户名 可以删除某用户 sudo userdel -r 用户名 可以把用户机器主目录删除 sudo id 用户名 查看该用户的信息 直接输入id 可以查看目前登陆的用户信息 sudo cat /etc/sudoers 查看etc目录下的配置 sudo updatedb ： 刷新数据库 sudo chmod 600 ××× （只有所有者有读和写的权限） sudo chmod 644 ××× （所有者有读和写的权限，组用户只有读的权限） sudo chmod 700 ××× （只有所有者有读和写以及执行的权限） sudo chmod 666 ××× （每个人都有读和写的权限） sudo chmod 777 ××× （每个人都有读和写以及执行的权限） /etc/group 记录所有组的名字，及组的成员列表，sudo cat group 可以查看，sudo用来提升权限 /etc/passwd 用户的关键信息存放在 /etc/passwd文件中 系统中每一个合法用户 对应一行记录 如 root1:x:1000:1000:root1,,,:/home/root1:/bin/bash （1）root1是用户名，（2）x代表密码（口令），被保存在shadow中，（3）1000为id符号，（4）属于1000组，（5）root1，（6）用户主目录为/home/root1，（7）表明用户的登录shell 上面提到的密码（口令），可由sudo cat shadow来查看，但无法直接看到密码，MD5加密的，34个字符，标志$1$ 进程管理 ps：查看当前所有进程 psaux：显示所有进程以及与进程相关的信息 pslax：提供父进程和子进程及其优先级 top： 动态显示进程状态，按q退出 lsof+文件名：查看哪个进程在占用某文件 kill：结束某进程 ， kill+进程号about:startpage","categories":[],"tags":[]},{"title":"hxd查看文件头,文件尾","slug":"hxd查看文件头-文件尾","date":"2018-10-29T13:34:55.000Z","updated":"2018-11-02T07:01:09.919Z","comments":true,"path":"2018/10/29/hxd查看文件头-文件尾/","link":"","permalink":"https://specters.top/2018/10/29/hxd查看文件头-文件尾/","excerpt":"在做题过程中发现，这个经常用，来总结一下","text":"在做题过程中发现，这个经常用，来总结一下 下面是一些 常见的JPEG (jpg)， 文件头：FFD8FF 文件尾：FF D9 PNG (png)， 文件头：89504E47 文件尾：AE 42 60 82GIF (gif)， 文件头：47494638 文件尾：00 3BZIP Archive (zip)， 文件头：504B0304 文件尾：50 4B 这些比较少见Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8FWindows Password (pwl)， 文件头：E3828596RAR Archive (rar)， 文件头：52617221Wave (wav)， 文件头：57415645TIFF (tif)， 文件头：49492A00 Windows Bitmap (bmp)， 文件头：424D HTML (html)， 文件头：68746D6C3EEmail [thorough only]， 文件头：44656C69766572792D646174653AOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043AVI (avi)， 文件头：41564920Real Audio (ram)， 文件头：2E7261FDReal Media (rm)， 文件头：2E524D46MPEG (mpg)， 文件头：000001BAMPEG (mpg)， 文件头：000001B3Quicktime (mov)， 文件头：6D6F6F76Windows Media (asf)， 文件头：3026B2758E66CF11MIDI (mid)， 文件头：4D546864CAD (dwg)， 文件头：41433130 Adobe Photoshop (psd)， 文件头：38425053 Rich Text Format (rtf)， 文件头：7B5C727466 XML (xml)， 文件头：3C3F786D6C","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-27T03:32:43.300Z","updated":"2018-10-27T03:32:43.300Z","comments":true,"path":"2018/10/27/hello-world/","link":"","permalink":"https://specters.top/2018/10/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}